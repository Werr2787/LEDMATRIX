// @file    XYMatrix.ino
// @brief   Demonstrates how to use an XY position helper function with a 2D matrix
// @example XYMatrix.ino

#include <FastLED.h>
//#include "noise_effects.ino"
#define LED_PIN  4

#define COLOR_ORDER GRB
#define CHIPSET     WS2811

#define BRIGHTNESS 250


// Вспомогательные функции для двумерной матрицы XY пикселей.
// Также включен простой двумерный демонстрационный код.
//
// XY(x,y) принимает координаты x и y и возвращает номер индекса светодиода,
// для использования следующим образом: leds[ XY(x,y) ] == CRGB::Red;
// Проверка ошибок не выполняется в диапазонах x и y.
//
// XYsafe(x,y) принимает координаты x и y и возвращает номер индекса светодиода,
// для использования следующим образом: leds[ XYsafe(x,y) ] == CRGB::Red;
// Проверка ошибок выполняется в диапазонах x и y, и возвращается
// индекс "-1". Специальные инструкции ниже
// объясняют, как использовать это без необходимости выполнять собственную проверку ошибок
// каждый раз при использовании этой функции.
// Это немного более продвинутая техника, и
// она ТРЕБУЕТ СПЕЦИАЛЬНОЙ ДОПОЛНИТЕЛЬНОЙ настройки, описанной ниже.


// Параметры ширины и высоты
const uint8_t kMatrixWidth = 8;
const uint8_t kMatrixHeight = 8;

// Параметр для различных макетов пикселей
const bool    kMatrixSerpentineLayout = true;
const bool    kMatrixVertical = false;
static const byte maxDim = max(kMatrixWidth, kMatrixHeight);
byte breathBrightness;
// Установите 'kMatrixSerpentineLayout' на false, если ваши пиксели
// расположены одинаково, например так:
//
// 0 > 1 > 2 > 3 > 4
// |
// .----<----<----<----'
// |
// 5 > 6 > 7 > 8 > 9
// |
// .----<----<----<----'
// |
// 10 > 11 > 12 > 13 > 14
// |
// .----<----<----<----'
// |
// 15 > 16 > 17 > 18 > 19
//
// Установите 'kMatrixSerpentineLayout' на true, если ваши пиксели
// расположены вперед и назад, например:
//
// 0 > 1 > 2 > 3 > 4
// |
// |
// 9 ​​< 8 < 7 < 6 < 5
// |
// |
// 10 > 11 > 12 > 13 > 14
// |
// |
// 19 < 18 < 17 < 16 < 15
//
// Бонусное словечко: все, что идет в одну сторону
// в одном ряду, а затем назад в следующем ряду и так далее
// называется "boustrophedon", что означает "как вол пашет".

// Эта функция вернет правильный «номер индекса светодиода» для
// заданного набора координат X и Y в вашей матрице.
// ОНА НЕ ПРОВЕРЯЕТ ГРАНИЦЫ КООРДИНАТ.
// Это на ваше усмотрение. Не передавайте ей фиктивные значения.
//
// Используйте функцию «XY» следующим образом:
//
// for( uint8_t x = 0; x < kMatrixWidth; x++) {
// for( uint8_t y = 0; y < kMatrixHeight; y++) {

// // Вот x, y для «индекса светодиода» в действии:
// leds[ XY( x, y) ] = CHSV( random8(), 255, 255);

// }
// }
//
//
#define NUM_LEDS (kMatrixWidth * kMatrixHeight)
CRGB leds[ NUM_LEDS ];
#define LAST_VISIBLE_LED 63
uint8_t XY (uint8_t x, uint8_t y) {
  // any out of bounds address maps to the first hidden pixel
  if ( (x >= kMatrixWidth) || (y >= kMatrixHeight) ) {
    return (LAST_VISIBLE_LED + 1);
  }

  const uint8_t XYTable[] = {
    63,  62,  61,  60,  59,  58,  57,  56,
    48,  49,  50,  51,  52,  53,  54,  55,
    47,  46,  45,  44,  43,  42,  41,  40,
    32,  33,  34,  35,  36,  37,  38,  39,
    31,  30,  29,  28,  27,  26,  25,  24,
    16,  17,  18,  19,  20,  21,  22,  23,
    15,  14,  13,  12,  11,  10,   9,   8,
     0,   1,   2,   3,   4,   5,   6,   7
  };

  uint8_t i = (y * kMatrixWidth) + x;
  uint8_t j = XYTable[i];
  return j;
}


// Как только вы освоите основы (НЕ ДО ЭТОГО!)
// вот полезный прием, который может быть сложным в настройке, но
// затем поможет вам избежать необходимости в разбрасывании проверки границ массива
// по всему вашему коду.
//
// Для правильной настройки требуется особое внимание, но
// потенциально он может сделать ваш код меньше и быстрее.
//
// Предположим, у вас есть матрица 8 x 5 из 40 светодиодов. Обычно вы
// делите свой массив светодиодов следующим образом:
// CRGB leds[40];
// Но вместо этого объявите буфер светодиодов с одним дополнительным пикселем в
// нем, "leds_plus_safety_pixel". Затем объявите "leds" как указатель на
// этот массив, но начиная со 2-го элемента (id=1) этого массива:
// CRGB leds_with_safety_pixel[41];
// CRGB* const leds( leds_plus_safety_pixel + 1);
// Затем вы используете массив "leds" как обычно.
// Теперь "leds[0..N]" — это псевдонимы для "leds_plus_safety_pixel[1..(N+1)]",
// И leds[-1] теперь является допустимым и безопасным псевдонимом для leds_plus_safety_pixel[0].
// leds_plus_safety_pixel[0] или leds[-1] теперь ваш "безопасный пиксель".
//
// Теперь вместо использования функции XY выше используйте функцию ниже, "XYsafe".
//
// Если значения X и Y находятся "в пределах", эта функция вернет индекс
// в видимый массив светодиодов, так же, как это делает "XY".
// ОДНАКО — и ​​в этом весь фокус — если значения X или Y
// выходят за пределы, эта функция вернет индекс -1.
// И поскольку leds[-1] на самом деле просто псевдоним для leds_plus_safety_pixel[0],
// это абсолютно безопасное и законное место для доступа. И поскольку «безопасный пиксель»
// находится «за пределами» видимой части светодиодной матрицы, все, что вы там напишете,
// автоматически скроется от просмотра.
// Таким образом, эта строка кода абсолютно безопасна, независимо от фактического размера
// вашей матрицы:
// leds[ XYsafe( random8(), random8() ) ] = CHSV( random8(), 255, 255);
//
// Единственная загвоздка здесь в том, что, хотя это делает безопасным чтение и
// запись в «любой пиксель», на самом деле есть только ОДИН «безопасный пиксель». Независимо от того,
// в какие внешние координаты вы записываете, на самом деле вы будете писать в
// этот один безопасный пиксель. И если вы попытаетесь ЧИТАТЬ из пикселя безопасности,
// вы прочтете то, что было там записано последним, независимо от того, какие координаты
// были предоставлены.

// #define NUM_LEDS (kMatrixWidth * kMatrixHeight)
// CRGB leds_plus_safety_pixel[ NUM_LEDS + 1];
// //оздает массив светодиодов leds_plus_safety_pixel, содержащий NUM_LEDS светодиодов,
// // а затем определяет указатель leds,
// // указывающий на этот массив с добавленным сдвигом на один элемент. 
// CRGB* const leds( leds_plus_safety_pixel + 1);


//Функция XYsafe используется для безопасного доступа к пикселям
// на светодиодной матрице с координатами x и y. 




// Демонстрация, которая ИСПОЛЬЗУЕТ "XY", следует коду ниже

//Функция loop() в бесконечном цикле вызывает функцию DrawOneFrame,
// которая отрисовывает анимацию изменяющихся цветов на матрице светодиодов.
// Цвета изменяются в зависимости от времени, а также настраивается яркость. 

void loop()
{
    matrixRoutine();
    delay(100);
    // //millis() возвращает количество миллисекунд, прошедших с момента запуска программы. 
    // //Значение сохраняется в переменной ms.
    // uint32_t ms = millis();
    // //yHueDelta32 и xHueDelta32 вычисляют изменение оттенка цвета по вертикали и горизонтали соответственно.
    // //Значения этих переменных зависят от времени (ms), 
    // //используют функцию cos16 для генерации значений и делят на ширину и высоту матрицы.
    // int32_t yHueDelta32 = ((int32_t)cos16( ms * (27/1) ) * (350 / kMatrixWidth));
    // int32_t xHueDelta32 = ((int32_t)cos16( ms * (39/1) ) * (310 / kMatrixHeight));
    // //Функция DrawOneFrame вызывается с передачей аргументов: 
    // //текущее время ms (поделенное на 65536) и значения yHueDelta32 и xHueDelta32, поделенные на 32768
    // DrawOneFrame( ms / 65536, yHueDelta32 / 32768, xHueDelta32 / 32768);
    // //Далее идет условие: если прошло менее 5 секунд (5000 миллисекунд),
    // //то яркость светодиодов изменяется плавно от 0 до BRIGHTNESS за 5 секунд, используя функцию scale8.
    // //В противном случае яркость остается на уровне BRIGHTNESS.
    // if( ms < 5000 ) {
    //   FastLED.setBrightness( scale8( BRIGHTNESS, (ms * 256) / 5000));
    // } else {
    //   FastLED.setBrightness(BRIGHTNESS);
    // }
    // //Наконец, вызывается FastLED.show(), чтобы обновить отображение на светодиодах с учетом всех изменений, произведенных в этом цикле
    FastLED.show();
}

void DrawOneFrame( uint8_t startHue8, int8_t yHueDelta8, int8_t xHueDelta8)//создания эффекта "бегущей радуги"
//- startHue8  - начальное значение оттенка цвета в диапазоне от 0 до 255.
//- yHueDelta8 - изменение оттенка цвета по вертикали.
//- xHueDelta8 - изменение оттенка цвета по горизонтали.
{
  //Затем функция использует вложенные циклы для прохода по каждому пикселю на светодиодной матрице или ленте.
  //Она вычисляет оттенок цвета для каждого пикселя на основе параметров startHue8, yHueDelta8 и xHueDelta8,
  uint8_t lineStartHue = startHue8;
  for( uint8_t y = 0; y < kMatrixHeight; y++) {
    lineStartHue += yHueDelta8;
    uint8_t pixelHue = lineStartHue;      
    for( uint8_t x = 0; x < kMatrixWidth; x++) {
      pixelHue += xHueDelta8;
      leds[ XY(x, y)]  = CHSV( pixelHue, 255, 255);
//устанавливает соответствующий цветовой оттенок и яркость для каждого пикселя с помощью функции CHSV (оттенок, насыщенность, яркость).
    }
  }
}




//Функция setup() устанавливает начальные параметры, такие как тип светодиодов, порт и порядок цветов.
void setup() {
  FastLED.addLeds<CHIPSET, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalSMD5050);
  //- leds - массив светодиодов для управления.
  //- NUM_LEDS - количество светодиодов в ленте.
  //- setCorrection(TypicalSMD5050) - устанавливает коррекцию цвета для конкретного типа светодиодов (в данном случае, для типичных SMD5050 светодиодов).
  FastLED.setBrightness( BRIGHTNESS );//яркость света
}
